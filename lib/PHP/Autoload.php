<?php
    /*
     * Библиотека множественной загрузки классов
     */

     class PHP_Autoload{

         # Массив содержит список функций, вызывающихся при запросе на
         # autoload
         static $funcs = array();

         # Переменная для проверки, успешно установлен ли главный обработчик
         # __autoload()
         static $ok = true;

         # Функция регистрирует новую функцию в списке обработчиков
         static function register($func){
             # В массив списка функций помещается ссылка на функцию и тем самым 
             # она становится зарегистрируемой
             self::$funcs[] =& $func;
         }

         # Функция удаляет функции из списка зарегистрированных обработчиков
         static function unregister($func){
             # Для удобства обработки в переменную F положили ссылку на массив 
             # со спискм функций
             $f =& self::$funcs;

             # Перебераем все элементы массива
             for($i = 0; $i < count($f); $i++){

                 # В стучае нахождения в массиве со списком функций той название
                 # которой пришло в аргументах ...
                 if($f[$i] === $func){

                     # ... то удаляем из массива со списком функий один элемент
                     # начинающийся с позиции $i
                     array_splice($f, $i, 1);
                     break;
                 }
             }
         }

         # Вызывается в момент запроса на autoload
         static function autoload($classname){
             static $loading = array();

             # Если класс не загружен, авызывается class_exists(),
             # происходит повторный запрос на autoload, и программа зацикливается. Что бы
             # избежать этого,проверяем, чтобы вход в autoload() с тем же именем
             # класса не происходил дважды
             if(@$loading[$classname])  return;

             # Идет загрузка. Если autoload() будет вызвана рекурсивно,
             # сработает предыдущая строчка.
             $loading[$classname] = true;

             # array_reverse() - возврящает массив с элементами в обратном порядке
             foreach(array_reverse(self::$funcs) as $f){

                 # Здесь происходит рекурсивный вызов autoload(),
                 # когда класс еще не загружен
                 # class_exists() - проверяет, был ли загружен класс
                 if(class_exists($classname)) break;

                 # Вызывает обработчик. Если он вернет false, значит,
                 # произошла какая-то ошибка, и необходимо запустить
                 # следующий по списку обработчик.
                 # call_user_func() - вызывает пользовательскую функцию
                 if(call_user_func($f, $classname)) break;
             }

             # Загрузка закончена
             $loading[$classname] = false;
         }
     }

     # Код, выполняемый при подключении библиотеки.
     # Устанавливает собственный глобальный обработчик
     # на __autoload, но только в случае, если такой обработчик еще не был
     # установлен где-то еще
     if(!function_exists("__autoload")){
         function __autoload($c){
             PHP_Autoload::autoload($c);
         }
     } else {
         PHP_Autoload::$ok = false;
     }